<html><head><meta http-equiv="Content-Type"content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="http://chengshuguang.com/blog/css/global.css" /><link rel="stylesheet" href="http://chengshuguang.com/blog/highlight/styles/rainbow.css"><script src="http://chengshuguang.com/blog/script/jquery.js" type="text/javascript"></script><script src="http://chengshuguang.com/blog/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><h1><center>	详解内核中得container_of宏</center></h1><p>我们知道linux内核代码中链表的实现用到了一个container_of宏定义，用来根据成员的地址来获取结构体的地址。</p><pre><code class="c">#define&nbsp;container_of(ptr,&nbsp;type,&nbsp;member)&nbsp;({&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;typeof(&nbsp;((type&nbsp;*)0)-&gt;member&nbsp;)&nbsp;*__mptr&nbsp;=&nbsp;(ptr);&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(type&nbsp;*)(&nbsp;(char&nbsp;*)__mptr&nbsp;-&nbsp;offsetof(type,member)&nbsp;);})<br/></pre></code><p>不知所云？请看下面分解:</p><hr><h3>预备知识</h3><h5>宏定义返回值</h5><p>宏定义能否也有返回值？当然是可以的。那么该如何实现宏定义的返回值呢，很简单：通过使用小括号<code>()</code>把函数体括起来使用宏定义可以得到该函数体<code>最后一条语句</code>运算结果。</p><pre><code class="c">/*&nbsp;return&nbsp;(a++)+(b++)&nbsp;*/<br/>#define&nbsp;addAB(a,&nbsp;b)&nbsp;({a++;&nbsp;b++;&nbsp;a+b;})</pre></code><p>详细或者更多用法 <a href="http://blog.csdn.net/shengnan_wu/article/details/8267700">》》》</a></p><h5 style="text-align:right;">offsetof的实现</h5><p><code>offsetof宏</code>在 stddef.h 头文件有定义，可以直接使用，但是理解其具体实现，对于理解container_of有很大的帮助。其实现如下：</p><pre><code class="c">#define&nbsp;offsetof(type,&nbsp;member)&nbsp;(size_t)&(((type&nbsp;*)0)-&gt;member)</pre></code><p>其作用是返回member在struct或者union结构中得偏移。</p><p><code>(type *)0</code>编译器会认为这是一个type类型的指针，并且起始地址为0。当然如果把0换成1，那么其起始地址就认为是1。这样一来，我们可以轻松的得到表示member成员<code>(((type *)0)-&gt;member)</code>。那么我们要得到offset，只需要取member的地址(前面我们说了该结构体起始地址为0)然后转换成size_t类型就是表示其偏移。</p><h3>container_of宏 </h3><p>下面让我们来一句句分析这个宏定义:</p><pre><code class="c">const&nbsp;typeof(&nbsp;((type&nbsp;*)0)-&gt;member&nbsp;)&nbsp;*__mptr&nbsp;=&nbsp;(ptr);</pre></code><p>这一句用到了<code>typeof</code>，表示这个member所表示的类型，定义了一个const的该类型指针__mptr，并指向ptr。</p><pre><code class="c">(type&nbsp;*)(&nbsp;(char&nbsp;*)__mptr&nbsp;-&nbsp;offsetof(type,member)&nbsp;);</pre></code><p>这一句，offsetof我们前面已经说过了，表示member在type这个结构中的偏移量；__mptr指针表示ptr指向的地址，这个地址可是真正的地址，不是上面说到得从0开始的地址；那么用这个真正的地址(<code>需要把__mptr转换成char *结构</code>)减去偏移，就得到了该结构体实际的起始地址。那么把这个地址转换成(type *)结构就表示了该结构的的地址，直接用该struct指针指向该地址，那么就根据member获得了整个结构体的地址。</p><p>同样，这一句，也是这个宏定义的返回值，就是返回了整个结构体的地址。</p><h3>举个栗子</h3><pre><code>#include&nbsp;&lt;stdio.h&gt;<br/>#include&nbsp;&lt;stdlib.h&gt;<br/><br/>#define&nbsp;offsetof(type,&nbsp;member)&nbsp;(size_t)&(((type&nbsp;*)0)-&gt;member)<br/><br/>#define&nbsp;container_of(ptr,&nbsp;type,&nbsp;member)&nbsp;({&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;typeof(&nbsp;((type&nbsp;*)0)-&gt;member&nbsp;)&nbsp;*__mptr&nbsp;=&nbsp;(ptr);&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(type&nbsp;*)(&nbsp;(char&nbsp;*)__mptr&nbsp;-&nbsp;offsetof(type,member)&nbsp;);})<br/><br/><br/>struct&nbsp;Student&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;id;<br/>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;sex;<br/>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;tmp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;age;<br/>};<br/><br/>int&nbsp;main()<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf("%d\n",&nbsp;offsetof(struct&nbsp;Student,&nbsp;sex));<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf("%d\n",&nbsp;offsetof(struct&nbsp;Student,&nbsp;age));<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf("%d\n",&nbsp;offsetof(struct&nbsp;Student,&nbsp;tmp));<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;Student&nbsp;*p1&nbsp;=&nbsp;(struct&nbsp;Student&nbsp;*)malloc(sizeof(struct&nbsp;Student));<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;p1-&gt;age&nbsp;=&nbsp;10;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;Student&nbsp;*p2;<br/><br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;由p1的age成员，得到了指向整个p1的指针p2&nbsp;*/<br/>&nbsp;&nbsp;&nbsp;&nbsp;p2&nbsp;=&nbsp;container_of(&(p1-&gt;age),&nbsp;struct&nbsp;Student,&nbsp;age);<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;printf("this&nbsp;is&nbsp;p2's&nbsp;age:%d\n",&nbsp;p2-&gt;age);<br/>&nbsp;&nbsp;&nbsp;&nbsp;printf("%p==%p\n",&nbsp;p1,&nbsp;p2);<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br/>}<br/></pre></code><h3>其他</h3><p>为了更好的理解container_of的使用，请看后续文章， <a href="kernel_list.html">kernel中链表的实现。</a></p><a href="https://github.com/codercheng/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://chengshuguang.com/pic_res/fork_me_on_github.png" alt="Fork me on GitHub" data-canonical-src="http://chengshuguang.com/pic_res/fork_me_on_github.png"></a></body></html>